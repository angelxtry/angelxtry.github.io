{"componentChunkName":"component---src-templates-blog-post-js","path":"/til/2019-12-02-TIL-2019-12-02/","result":{"data":{"site":{"siteMetadata":{"title":"TIL","author":"[Suho]","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"angelxtry/blog-comment"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"04c93bca-3170-5f4f-82b9-ed3d354a064b","excerpt":"[번역] useEffect 완벽 가이드를 읽었다. 너무 * 3 재미있게 읽었다. 급하게 코드를 작성하느라고 놓치고 있었던 부분을 조금 더 진지하게 생각할 수 있는 계기가 되었다. 예를 들어 state를 업데이트할 때마다, 리액트는 컴포넌트를 호출합니다. 매 랜더 결과물은 고유의 counter 상태 값을 “살펴봅니다”. 그리고 이 값은 함수 안에 상수로 존재하는 값입니다. 이건 랜더링 결과물에 숫자 값을 내장하는 것에 불과합니다. 이 숫자 값은 리액트를 통헤 제공됩니다. setCount…","html":"<p><a href=\"https://rinae.dev/posts/a-complete-guide-to-useeffect-ko\">[번역] useEffect 완벽 가이드</a>를 읽었다.</p>\n<p>너무 * 3 재미있게 읽었다.</p>\n<p>급하게 코드를 작성하느라고 놓치고 있었던 부분을 조금 더 진지하게 생각할 수 있는 계기가 되었다.</p>\n<p>예를 들어</p>\n<blockquote>\n<p>state를 업데이트할 때마다, 리액트는 컴포넌트를 호출합니다. 매 랜더 결과물은 고유의 counter 상태 값을 “살펴봅니다”. 그리고 이 값은 함수 안에 상수로 존재하는 값입니다.</p>\n<p>이건 랜더링 결과물에 숫자 값을 내장하는 것에 불과합니다. 이 숫자 값은 리액트를 통헤 제공됩니다. setCount 를 호출할 때, 리액트는 다른 count 값과 함께 컴포넌트를 다시 호출합니다. 그러면 리액트는 가장 최신의 랜더링 결과물과 일치하도록 DOM을 업데이트 합니다.</p>\n<p>명심하셔야 할 점은 여느 특정 랜더링 시 그 안에 있는 count 상수는 시간이 지난다고 바뀌는 것이 아니라는 것입니다. 컴포넌트가 다시 호출되고, 각각의 랜더링마다 격리된 고유의 count 값을 “보는” 것입니다.</p>\n</blockquote>\n<p>이런 내용을 react를 처음 접했을 때 스쳐지나가듯 읽었었는데 까맣게 잊고 있었다.</p>\n<p>쉽게 접할 수 있도록 번역 해주신 분에게 감사드린다.</p>\n<p>이틀 정도 뒤에 다시 한번 읽어보려고 한다.</p>\n<p>그리고 이 글에 링크된 내용도 일정을 만들어서 읽어봐야지~</p>\n<p>하루하루가 즐겁다.</p>","frontmatter":{"title":"[TIL] 2019-12-02","date":"December 02, 2019"}}},"pageContext":{"slug":"/til/2019-12-02-TIL-2019-12-02/","previous":{"fields":{"slug":"/development/2019-11-29-use-Momentjs/"},"frontmatter":{"title":"Moment.js 사용했던 것 정리","category":"development"}},"next":{"fields":{"slug":"/development/2019-12-03-setting-eslint-prettier/"},"frontmatter":{"title":"2019-12-03 eslint, prettier 설정","category":"development"}}}}}
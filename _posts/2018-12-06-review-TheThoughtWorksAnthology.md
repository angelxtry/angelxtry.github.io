---
layout: post
comments: true
title: "[Book review] 소트웍스 앤솔러지"
tags:
  - book
  - review
  - 객체지향 생활체조
  - DSL
---

## 감상

올 해 참석했던 컨퍼런스에서 짧게 소개되었던 책이다. 마틴 파울러나 쏘트웍스가 유명해서 표지는 기억하고 있던 책이었는데 컨퍼런스를 계기로 읽게 됐다.

책을 받아 보니 역자분이 이창신님이었다. 우연히 같이 읽고 있던 `프로그래머를 위한 선형대수`도 이창신님의 번역서였다. 같은 역자분의 책을 동시에 읽는 신기한 경험!

초판발행이 2009년인 오래된 책이다. 그래서 적당히 넘긴 부분도 꽤 된다. 그래도 3장, 4장, 5장, 6장은 재미있게 읽었다.

ThoughtWorks라는 회사는 아직도 건재하다. 자세히 검색해보지는 않았지만 [홈페이지](https://www.thoughtworks.com/)를 통해 꾸준히 글을 발표하는 듯 하다.

3장 악당 소술과 20개의 루비 DSL

DSL을 상세하게 설명하는 책을 처음 읽었다. 다른 책에서 DSL이 언급되었을 때 막연히 감으로만 상상했었는데 그리 복잡하지 않지만 구체적인 내용을 볼 수 있어 좋았다.

4장 프로그래밍 언어의 울창한 숲

다양한 패러다임, 다양한 언어를 한 자리에 모아 놓고 비교하는 과정이 재미있다.

6장 객체지향 생활체조

책이 출간되었을 시점에 꽤나 유명했었는지 찾아보니 글이 많이 보인다. 괜찮은 지침인 듯 싶어 따라해봤는데 쉽지 않다. 포기하지 말고 꾸준히 연습해보자.

다 읽은 뒤에 보니 3장, 4장, 6장 외에는 큰 의미를 찾지 못하겠다. 굳이 사서 볼 필요는 없어보인다. 시간이 좀 지난 후에 보면 다르게 보일까?

## 기억에 남는 부분

### 3장 악당 소술과 20개의 루비 DSL

31p
> 이 코드에서는 새로 생성된 아이템을 반환하는 부분이 핵심인데, 이렇게 하기 때문에 메서드 연결하기가 가능해진다.
이런 방식의 메서드 연결하기는 여러 좋은 프로그래밍 지침들과 상충된다. 대부분의 언어들에서 modifier(객체의 상태를 변화시키는 메서드)는 아무것도 반환하지 않는다. 이렇게 하는 이유는 명령과 쿼리의 분리라는 원칙을 따르기 위한 것이다. 이 원칙은 대부분의 경우 잘 따르는 것이 좋다.
DSL을 고안하는 입장에서는 DSL에서 메서드 연결하기를 지원하기 위한 코드를 작성하는 동안엔 이 원칙을 포기하곤 한다.

객체를 리턴해서 메서드 체인을 하는 방식도 재미있어보인다.

### 4장 프로그래밍 언어의 울창한 숲

55p
> 여러 언어의 특징들에 대한 이해는 컴퓨터 언어 세상에 새로 유입되는 언어들을 이해하기 위한 강력한 기반이 된다.

> 컴퓨터 언어는 제공되는 문장의 종류, 타입을 다루는 방식, 언어가 구현된 방식, 기본적인 구조화 원칙 등에 의해 구분된다.

포트란
명령형 프로그래밍 언어
정적 언어 - 소스 코드가 컴파일 및 링크된 후에 로딩 및 실행될 수 있다.

리스프
함수형 언어
동적 언어
동적 타입 언어 - 명령문이 실행되기 전에는 특정 값의 타입이 결정되지 않는다. 변수의 타입은 그 안에 담겨 있는 값에 의해 결정된다.

자바
객체지향 프로그래밍 언어

하스켈
순수 함수형 언어
정적 타입 시스템 - 명시적 타입 선언을 줄이기 위해 타입 추론을 활용한다.
지연적 언어 - 최종 결과를 계산하기 위해 쓰이지 않는 부분은 결코 평가하지 않는다.

SQL
선언적 언어 - 어떻게 계산할 것인지가 아니라 무엇을 계산할 것인지를 표현한다.
비선언적 언어의 추상화 수준이 높아질수록, 또 컴파일러 최적화가 좀 더 적극적으로 수행될수록 선언적 언어와 비선언적 언어 사이의 경계는 흐릿해진다.

얼랭
함수형 언어
엄격한 타입 언어, 동적 타입 언어
동시적 계산을 언어 수준에서 명시적으로 지원

패러다임

- 명령형: 상태를 변경하는 명령문의 나열
- 절차형: 명령문의 집합인 프로시저로 구성
- 객체지향: 객체
- 함수형: 상태 없는 함수들로 구성
- 선언적: 답을 얻기 위한 방법이 아닌 답 자체에 대해 기술

>패러다임은 세 가지 서로 다른 특성들이 섞여 있다. 이 특성이란 구조화 방식, 상태, 그리고 범위(scoping)를 말한다.

> 각 패러다임은 코드를 서로 다른 방식으로 구조화한다. 객체를 쓰기도 하고 함수, 프로시저 혹은 하나의 단일 문장이 기본적인 구조화 단위가 되기도 한다.

> 두 번째는 상태이다. 명령형 언어에서는 메모리 상태를 직접적으로 조작하는 반면 함수형 언어에서는 어떠한 상태로 명시적으로 변경되지 않는다.

> 범위는 상태의 가시성에 대한 개념이다. 객체지향 언어에서는 상태가 객체에 딸려 있으며 객체의 상태는 객체 자신만이 불 수 있다. 명령형 언어에는 소스코드의 모든 곳에서 접근할 수 있는 전역적인 상태가 존재한다. 함수형 언어에서는 함수의 클로저 내에서 변수와 값 사이의 바인딩이 이루어지는데 이 값들은 변경도 불가능하고 다른 함수에서는 접근할 수도 없다.

타입 특성

- 정적 타입: 변수의 타입이 고정되며, 보통 컴파일 시에 결정됨
- 동적 타입: 변수의 타입이 사용되는 시점에 결정됨
- 강타입: 실행 중 타입 에러가 발생할 수 없음
- 타입 추론: 명시적 타입 선언 없이 타입 추론에 의해 변수에 타입이 할당됨
- duck 타입: 타입 중 실제로 필요한 부분만 검사됨

실행 방식

- 순차적 언어 vs 동시성 언어
- 지연적 언어 vs 엄격한 언어

구현 모델

- 컴파일 언어 vs 인터프리트 언어
- 가상 머신이 널리 쓰이기 시작하면서 컴파일 언어와 인터프리트 언어의 경계가 점점 흐려지게 되었다.

### 5장 다언어 프로그래밍

81p
> 이런저런 솔루션을 하나의 언어에 쑤셔 넣으려던 시절은 끝나가고 있다. (자바나 CLR과 같은) 훌륭한 관리 런타임이 있기에, 더 나은 도구로 이들 플랫폼을 활용해야 한다. 다언어 프로그래밍은 중요한 작업을 맡던 기존 코드를 버리지 않고도 솔루션별로 맞춤 대응을 할 수 있게 해준다.

### 6장 객체지향 생활 체조

83p
> 이 글에서는 이제 프로그래밍을 시작하려는 사람에게 코드 작성 시 베스트 프랙티스를 배울 기회를 제공하려 한다. 고급 숙련 프로그래머에게는 베스트 프랙티스를 환기하거나 동료를 교화시키고자 할 때 시연의 목적으로 사용할 수단을 주려 한다.

85p
규칙

- 1.한 메서드에 오직 한 단계의 들여쓰기만 한다.
- 2.else keyword를 쓰지 않는다.
- 3.모든 원시값과 문자열을 포장wrap 한다.
- 4.한 줄에 점을 하나만 찍는다.
- 5.줄여쓰지 않는다(축약금지).
- 6.모든 entity를 작게 유지한다.
- 7.2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- 8.fist-class collection을 쓴다.
- 9.getter, setter, property를 쓰지 않는다.

8, 9번 규칙은 어떤 의미인지 이해되지 않는다. ㅜ_ㅜ 좀 더 찾아봐야겠다.

#### 1. 메서드당 들여쓰기 한 번

> 각 메서드가 정확히 한 가지 일을 하는지, 즉 메서드당 하나의 제어 구조나 하나의 block으로 되어 있는지를 지키려고 노력한다. 한 메서드 안에 중첩된 제어 구조가 있다면 다단계의 추상화를 코드로 짠 것이며, 한 가지 이상의 일을 하고 있다는 뜻이다.

#### 2. else keyword를 쓰지 않는다

> 객체지향 언어는 다형성이라는 강력한 도구를 통해 복잡한 조건문을 처리할 수 있다. 간단한 경우라면 보호절 guard clause과 조기 반환 early return으로 대체 가능하다.

> Strategy 패턴, Null 오브젝트 패턴 등 활용

#### 3. 모든 원시값과 문자열을 포장wrap 한다

> 어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 않아야 한다.

> 원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다. 오브젝트로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며 왜 쓰이고 있는지에 대한 정보를 전하는 셈이다.

#### 4. 한 줄에 점을 하나만 찍는다

> 여러 개의 점이 들어 있는 코드 몇 줄을 들여다보기 시작하면 책임소재의 오류를 많이 발견하기 시작한다. 어떠한 코드 한 줄에서라도 점이 하나 이상 있으면 동작이 일어나고 있다는 뜻이다. 모든 점들이 연결되어 있다면 대상 오브젝트는 딴 오브젝트에 깊숙이 관여하고 있다. 오브젝트가 자기 속을 들여다 보려 하기보다는 뭔가 작업을 하도록 만들어야 한다. 캡슐화의 주요점은 클래스 경계를 벗아나 알 필요가 없는 타입으로 진입하지 않는 것이다.

#### 5. 축약 금지

> 클래스, 메서드, 변수의 이름을 줄이려는 유혹에 곧잘 빠지곤 한다. 그런 유혹을 뿌리쳐라.

> 왜 축약을 하고 싶은가. 계속 반복해서 똑같은 단어를 치기 때문이 아닐까? 만일 그 경우라면 아마도 메서드가 너무 자주 사용되어 중복을 없앨 기회를 놓치고 있는 것이다. 메서드 이름이 길어지고 있다면 책임소재의 오류나 클래스의 부재라는 신호탄일지 모른다.

> 클래스와 메서드 이름을 한 두 단어로 유지하려고 애쓰고 문맥을 중복하는 이름을 피하자.

> 이 훈련을 위해 모든 엔티티는 한 두 단어로 된 이름을 축약 없이 가져야 한다.

#### 6. 모든 entity를 작게 유지한다

> 이 말은 50줄 이상 되는 클래스와 10개 파일 이상되는 패키지는 없어야 한다는 뜻이다.

> 50줄 이상의 클래스는 보통 한 가지 이상의 일을 하는 것이다.

> 패키지 크기를 제한해야 패키지가 하나의 목적을 달성하기 위해 모인 연관 클래스들의 집합임을 알아차리게 된다.

#### 7. 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다

> 기존 클래스에 새로운 인스턴스 변수를 하나 더 추가하면 클래스의 응집도는 즉시 떨어진다. 이 규칙으로 프로그래밍을 하는 동안 클래스는 두 종류, 즉 인스턴스 변수 한 개의 상태를 유지하는 종류와 두 개의 독립된 변수를 조율하는 종류가 있음을 파악하게 된다.

> 분해 과정을 진행하다가 막히게 되면, 오브젝트들을 연관있는 것들로 묶어 반으로 쪼개는 식으로 내려가거나 두 인스턴스 변수를 골라 하나의 오브젝트를 만드는 식으로 올라간다.

#### 8. fist-class collection을 쓴다

> 콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.

#### 9.getter, setter, property를 쓰지 않는다

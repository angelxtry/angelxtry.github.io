---
layout: post
comments: true
title: "[Solve] Last digit of a large number"
tags:
  - CodeWars
  - python
  - pow
---

# Last digit of a large number

두 숫자를 인자로 받아 첫 번째 인자에 두 번쩨 인자를 제곱한 값의 1의 자리 숫자를 반환하라.
두 숫자는 모두 양의 정수다.

## 내가 작성한 코드

```py
def last_digit(n1, n2):
    target = int(str(n1)[-1])

    dic = {
        0: [0, 0, 0, 0],
        1: [1, 1, 1, 1],
        2: [2, 4, 8, 6],
        3: [3, 9, 7, 1],
        4: [4, 6, 4, 6],
        5: [5, 5, 5, 5],
        6: [6, 6, 6, 6],
        7: [7, 9, 3, 1],
        8: [8, 4, 2, 6],
        9: [9, 1, 9, 1],
    }
    return 1 if n2 == 0 else dic[target][(n2 % 4) - 1]
```

첫 번째 인자를 문자열로 변환해서 1의 자리 숫자를 찾았다.

결과를 보니 좀 허탈했다. 이렇게 간단하게 해결할 수 있다니!

## best solution

```py
def best_solve(n1, n2):
    return pow(n1, n2, 10)
```

pow 함수에 세 번째 인자가 있는지 처음 알았다. 게다가 modular 역할이라니? 왜 pow 함수에 modular 연산을하는 인자가 필요했을까? 게다가 연산도 빠르다.

```py
def best_solve2(n1, n2):
    dic = {
        0: [0, 0, 0, 0],
        1: [1, 1, 1, 1],
        2: [6, 2, 4, 8],
        3: [1, 3, 9, 7],
        4: [6, 4, 6, 4],
        5: [5, 5, 5, 5],
        6: [6, 6, 6, 6],
        7: [1, 7, 9, 3],
        8: [6, 8, 4, 2],
        9: [1, 9, 1, 9],
    }
    return 1 if n2 == 0 else dic[n1 % 10][n2 % 4]
```

내가 작성한 코드와 비슷하지만 훨씬 더 깔끔하다. 일단 `% 10`을 이용하여 1의 자리 숫자를 구했다. 그리고 배열의 순서를 변경해서 `(n2 % 4) - 1`을 `n2 % 4`로 만들었다.

코드가 훨씬 깔끔해보인다. 기억해두자.

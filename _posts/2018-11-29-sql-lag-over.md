---
layout: post
comments: true
title: "[SQL] 그룹핑하여 이전 값과 비교"
tags:
  - sql
  - oracle
---

```sql
WITH TBL AS (
    SELECT '20181101' DATE_FROM, '20181103' DATE_TO, 'ABC' AS NAME, 1 AS SCORE FROM DUAL UNION ALL
    SELECT '20181104' DATE_FROM, '20181105' DATE_TO, 'ABC' AS NAME, 2 AS SCORE FROM DUAL UNION ALL
    SELECT '20181106' DATE_FROM, '20181110' DATE_TO, 'ABC' AS NAME, 5 AS SCORE FROM DUAL UNION ALL
    SELECT '20181111' DATE_FROM, '20181121' DATE_TO, 'ABC' AS NAME, 8 AS SCORE FROM DUAL UNION ALL
    SELECT '20181122' DATE_FROM, '20181123' DATE_TO, 'ABC' AS NAME, 9 AS SCORE FROM DUAL UNION ALL
    SELECT '20181101' DATE_FROM, '20181102' DATE_TO, 'CDE' AS NAME, 1 AS SCORE FROM DUAL UNION ALL
    SELECT '20181103' DATE_FROM, '20181108' DATE_TO, 'CDE' AS NAME, 5 AS SCORE FROM DUAL UNION ALL
    SELECT '20181109' DATE_FROM, '20181115' DATE_TO, 'CDE' AS NAME, 9 AS SCORE FROM DUAL UNION ALL
    SELECT '20181116' DATE_FROM, '20181120' DATE_TO, 'CDE' AS NAME, 12 AS SCORE FROM DUAL UNION ALL
    SELECT '20181121' DATE_FROM, '20181122' DATE_TO, 'CDE' AS NAME, 11 AS SCORE FROM DUAL
)
SELECT DATE_FROM, DATE_TO, NAME, SCORE
FROM TBL
;
```

| DATE_FROM | DATE_TO  | NAME | SCORE |
| --------- | -------- | ---- | ----- |
| 20181101  | 20181103 | ABC  | 1     |
| 20181104  | 20181105 | ABC  | 2     |
| 20181106  | 20181110 | ABC  | 5     |
| 20181111  | 20181121 | ABC  | 8     |
| 20181122  | 20181123 | ABC  | 9     |
| 20181101  | 20181102 | CDE  | 1     |
| 20181103  | 20181108 | CDE  | 5     |
| 20181109  | 20181115 | CDE  | 9     |
| 20181116  | 20181120 | CDE  | 12    |
| 20181121  | 20181122 | CDE  | 11    |

위와 같은 데이터가 있다. 날짜가 From ~ To로 입력되어 있고 NAME으로 groub by 할 수 있는 데이터다.

데이터를 NAME과 날짜로 정렬하고 SCORE가 이전 기간보다 얼마나 변화했는지 확인해보자. 변화량을 확인하려면 해당 기간의 값과 이전 기간의 값을 비교해야 한다.

```sql
WITH TBL AS (
    SELECT '20181101' DATE_FROM, '20181103' DATE_TO, 'ABC' AS NAME, 1 AS SCORE FROM DUAL UNION ALL
    SELECT '20181104' DATE_FROM, '20181105' DATE_TO, 'ABC' AS NAME, 2 AS SCORE FROM DUAL UNION ALL
    SELECT '20181106' DATE_FROM, '20181110' DATE_TO, 'ABC' AS NAME, 5 AS SCORE FROM DUAL UNION ALL
    SELECT '20181111' DATE_FROM, '20181121' DATE_TO, 'ABC' AS NAME, 8 AS SCORE FROM DUAL UNION ALL
    SELECT '20181122' DATE_FROM, '20181123' DATE_TO, 'ABC' AS NAME, 9 AS SCORE FROM DUAL UNION ALL
    SELECT '20181101' DATE_FROM, '20181102' DATE_TO, 'CDE' AS NAME, 1 AS SCORE FROM DUAL UNION ALL
    SELECT '20181103' DATE_FROM, '20181108' DATE_TO, 'CDE' AS NAME, 5 AS SCORE FROM DUAL UNION ALL
    SELECT '20181109' DATE_FROM, '20181115' DATE_TO, 'CDE' AS NAME, 9 AS SCORE FROM DUAL UNION ALL
    SELECT '20181116' DATE_FROM, '20181120' DATE_TO, 'CDE' AS NAME, 12 AS SCORE FROM DUAL UNION ALL
    SELECT '20181121' DATE_FROM, '20181122' DATE_TO, 'CDE' AS NAME, 11 AS SCORE FROM DUAL
)
SELECT
DATE_FROM
, DATE_TO
, NAME
, SCORE
, LAG(SCORE) OVER(PARTITION BY NAME ORDER BY DATE_FROM) BEFORE_SCORE
, SCORE - LAG(SCORE) OVER(PARTITION BY NAME ORDER BY DATE_FROM) AS GROWTH
FROM TBL
;
```

| DATE_FROM | DATE_TO  | NAME | SCORE | BEFORE_SCORE | GROWTH |
| --------- | -------- | ---- | ----- | ------------ | ------ |
| 20181101  | 20181103 | ABC  | 1     | -            | -      |
| 20181104  | 20181105 | ABC  | 2     | 1            | 1      |
| 20181106  | 20181110 | ABC  | 5     | 2            | 3      |
| 20181111  | 20181121 | ABC  | 8     | 5            | 3      |
| 20181122  | 20181123 | ABC  | 9     | 8            | 1      |
| 20181101  | 20181102 | CDE  | 1     | -            | -      |
| 20181103  | 20181108 | CDE  | 5     | 1            | 4      |
| 20181109  | 20181115 | CDE  | 9     | 5            | 4      |
| 20181116  | 20181120 | CDE  | 12    | 9            | 3      |
| 20181121  | 20181122 | CDE  | 11    | 12           | -1     |

LAG, OVER 함수를 사용했다.
OVER는 GROUP BY, ORDER BY 같은 동작을 수행한다. 위 sql에서 PARTITION BY가 GROUP BY를 대신한다. PARTITION BY, ORDER BY 사이에 `,`가 필요없다. 함수의 매개변수처럼 생각되어서 꼭 `,`를 붙였다가 수정하곤 한다.
LAG 함수는 OVER 함수를 통한 결과에서 한 줄씩 다음 ROW의 값을 선택한다. LAG와 대칭되는 함수가 LEAD다.
OVER에서 사용할 수 있는 OPTION

- ORDER BY
- PARTITION BY
- NULLS FIRST
- NULLS LAST
